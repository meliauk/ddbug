{"./":{"url":"./","title":"关于我","keywords":"","body":"Bug-Record 专注于记录bug Bug制造者 王余凡 某某某 Q Q：联系我吧 ! function chatQQ(){ if ((navigator.userAgent.match(/(iPhone|iPod|Android|ios|iOS|iPad|Backerry|WebOS|Symbian|Windows Phone|Phone)/i))) { /*手机*/ window.location.href=\"mqqwpa://im/chat?chat_type=wpa&uin=2050781802&version=1&src_type=web&web_src=oicqzone.com\"; }else{ /*电脑*/ // window.location.href=\"http://wpa.qq.com/msgrd?v=3&uin=2050781802&site=qq&menu=yes\"; window.location.href=\"tencent://message/?uin=2050781802&Site=Sambow&Menu=yes\"; } } Copyright © 无人问我粥可温 all right reserved，powered by Gitbook最后更新时间： 2023-12-12 09:21:50 "},"bug/前端/vue/initVue.html":{"url":"bug/前端/vue/initVue.html","title":"vue","keywords":"","body":"数据更新，DOM未刷新 dom元素加if判断 0\":loading=\"tableObject.loading\" > Copyright © 无人问我粥可温 all right reserved，powered by Gitbook最后更新时间： 2023-12-12 09:21:50 "},"bug/前端/vue/页面实时数据监听.html":{"url":"bug/前端/vue/页面实时数据监听.html","title":"页面实时数据监听","keywords":"","body":"需求 无需手动点击刷新页面数据实时同步更新 实现想法一 定时器setInterval+watch setInterval(() => { let _that = this; setTimeout( function () { _that.getlist(); //加载数据函数 自己的方法 console.log(\"刷新\" + new Date()); }, 0); }, 1000); watch，它可以用来监测Vue实例上的数据变动 于是发现比较浪费性能并没有达到我想要的预期效果 实现想法二 ajax的长轮询 Ajax轮询：客户端是按照规定时间像服务端发送请求，前一次请求完成后，无论有无结果返回，规定时间之后下一次请求又会发出 Ajax长轮询：当服务端收到客户端发来的请求后,服务端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。 客户端JavaScript响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。既把循环放到了服务端 启动类上开启异步 @EnableAsync @RequestMapping(\"/async\") @RestController public class AsyncRequestDemo { @Autowired private AsyncRequestService asyncRequestService; @GetMapping(\"/value\") public String getValue() { String msg = null; Future result = null; try{ result = asyncRequestService.getValue(); msg = result.get(10, TimeUnit.SECONDS); }catch (Exception e){ e.printStackTrace(); }finally { if (result != null){ result.cancel(true); } } return msg; } @PostMapping(\"/value\") public void postValue(String msg) { asyncRequestService.postValue(msg); } } @Service public class AsyncRequestService { private String msg = null; @Async public Future getValue() throws InterruptedException { while (true){ synchronized (this){ if (msg != null){ String resultMsg = msg; msg = null; return new AsyncResult(resultMsg); } } Thread.sleep(100); } } public synchronized void postValue(String msg) { this.msg = msg; } } 这里是根据 msg 是否变化判断是否响应返回 @EnableAsync 开启异步 @Sync 标记异步方法 Future 用于接收异步返回值 result.get(10, TimeUnit.SECONDS); 阻塞，超时获取结果 Future.cancel() 中断线程 于是发现在多端中判断服务器端数据是否有更新自己发现比较困难 实现想法三 websocket 收到客户端消息后既对数据请求响应，数据的实时同步性比较好， org.springframework.boot spring-boot-starter-websocket /** * 前后端交互的类实现消息的接收推送(自己发送给自己) * * @ServerEndpoint(value = \"/ws/one\") 前端通过此URI和后端交互，建立连接 */ @Slf4j @ServerEndpoint(value = \"/ws/one/{userid}\",encoders = { EncoderClassVo.class }) @Component public class OneWebSocket { /** * 与某个客户端的连接对话，需要通过它来给客户端发送消息 */ private Session session; /** * 标识当前连接客户端的用户名 */ private String userid; /** * 用于存所有的连接服务的客户端，这个对象存储是安全的 */ private static ConcurrentHashMap webSocketSet = new ConcurrentHashMap<>(); // websocket 不能注入( @Autowired ) private static VdataService vdataService; @Autowired public void setVdataService(VdataService vdataService) { OneWebSocket.vdataService = vdataService; } /** * 记录当前在线连接数 */ // private static AtomicInteger onlineCount = new AtomicInteger(0); /** * 连接建立成功调用的方法 */ @OnOpen public void onOpen(Session session, @PathParam(value = \"userid\")String userid) { this.session = session; this.userid = userid; // userid是用来表示唯一客户端，如果需要指定发送，需要指定发送通过userid来区分 webSocketSet.put(userid,this); // onlineCount.incrementAndGet(); // 在线数加1 log.info(\"有新连接加入：用户id，{}，当前在线人数为：{}\",this.userid, webSocketSet.size()); } /** * 连接关闭调用的方法 */ @OnClose public void onClose(Session session) { // onlineCount.decrementAndGet(); // 在线数减1 webSocketSet.remove(this.userid); log.info(\"有一连接关闭：{}，用户id，{}，当前在线人数为：{}\", session.getId(),this.userid, webSocketSet.size()); } /** * 收到客户端消息后调用的方法 * * @param message 客户端发送过来的消息 */ @OnMessage public void onMessage(String message) throws ExecutionException, InterruptedException { // 你的业务逻辑 JSONObject obj = JSONUtil.parseObj(message); String userid = obj.get(\"userid\").toString(); String page = obj.get(\"page\").toString(); String size = obj.get(\"size\").toString(); String isend = obj.get(\"isend\").toString(); System.err.println(obj); Future vData = vdataService.getlistVData(Integer.parseInt(userid), page, size, Integer.parseInt(isend)); log.info(\"服务端 收到 客户端 [{}]的消息:{}\", userid, message); // 你的业务逻辑 this.sendMessage(ResultDTO.success(vData.get()), userid); } @OnError public void onError(Throwable error) { webSocketSet.remove(this.userid); log.error(\"发生错误\"); error.printStackTrace(); } /** * 服务端发送消息给客户端 */ private void sendMessage(ResultDTO message, String userid) { System.err.println(\"userid \"+userid); try { log.info(\"服务端 给 客户端[{}]发送消息{}\", userid, JSONUtil.parseObj(message)); webSocketSet.get(userid).session.getBasicRemote().sendObject(message); } catch (Exception e) { log.error(\"服务端发送消息给客户端失败：{}\", e); } } } 发现服务端发送消息给客户端发送消息发送的object类型解析不了 需要配置解析类 public class EncoderClassVo implements Encoder.Text{ @Override public void init(EndpointConfig config) { // TODO Auto-generated method stub } @Override public void destroy() { // TODO Auto-generated method stub } //如果你传递的是一个类，则使用如下写法 @Override public String encode(ResultDTO resultDTO) throws EncodeException { return JSONUtil.toJsonStr(resultDTO); } } destroyed() { this.websock.close() //离开路由之后断开websocket连接 }, created() { this.initWebSocket(); }, initWebSocket(){ //初始化weosocket console.log(\"初始化weosocket\"); const wsuri = \"ws://127.0.0.1:80/ws/one/\"+this.userid; this.websock = new WebSocket(wsuri); this.websock.onopen = this.websocketonopen; this.websock.onmessage = this.websocketonmessage; this.websock.onerror = this.websocketonerror; this.websock.onclose = this.websocketclose; }, websocketonopen(){ //连接建立之后执行send方法发送数据 console.log(\"websocket-连接成功\") let data = {\"hi\":\"发送数据\"}; this.websocketsend(JSON.stringify(data)); }, websocketonerror(){//连接建立失败重连 this.initWebSocket(); }, websocketonmessage(e){ //数据接收 const redata = JSON.parse(e.data); console.log(\"ws--数据接收\") this.listData = redata.data.records; console.log(redata) }, websocketsend(Data){//数据发送 this.websock.send(Data); }, websocketclose(e){ //关闭 console.log('断开连接',e); }, 在有数据操作的地方只需向服务端发送消息即可 new OneWebSocket().onMessage(msg); 于是实现了自己想要的功能，以此记录 2021-02-01 10:36:08 星期一 Copyright © 无人问我粥可温 all right reserved，powered by Gitbook最后更新时间： 2023-12-12 09:21:50 "},"bug/后端/wft.html":{"url":"bug/后端/wft.html","title":"wft","keywords":"","body":"威富通 快捷对账 1，新增对账处理器 实现 cn.swiftpass.core.server.acc.service.billdownloader.impl.AbstractCheckBillProcessor @Service @ApiProvider(apiProviderValue = AccConstants.自己约定的值) public class WlmqFastPayCheckBillProcessor extends AbstractCheckBillProcessor { 重写 beforeProcess，下载文件前做些什么 getTargetDownFileName，获取下载文件名称 downloadCheckBillInner，下载第三方账单 parsePayOrderDtoByLine，按照行解析文件， 这里把第三方订单信息存放thirdMap， 需关注存入的是否为威富通订单号 1，key 威富通订单号 2，key 不是威富通订单号 } 2，对账前置校验 cn.swiftpass.core.server.acc.account.worker.CheckBillWorker#validate 需改动 如果第三方返回的有下载路径，这不需要验证，配置下载文件路径 // 需要对账方式-任务没有配置下载文件路径 if (payCenterDto.getApiProvider()!=API_PROVIDER_FAST_CARD ......) { logger.error(\"第三方下载地址为空，请检查。任务id={}\", task.getTaskId()); return false; } 如果第三方没用返回下载路径 cn.swiftpass.core.server.acc.service.impl.CheckBillTaskServiceImpl#buildCheckBillTask 修改 设置对账下载路径 /** 下载任务属性初始化 */ // 设置对账下载路径 if (AccConstants.API_PROVIDER_FAST == payCenterDto.getApiProvider()) { String downloadMessage = payCenterDto.getDownLoadMessage(); Map downMsgMap = JSON.parseObject(downloadMessage, Map.class); if (downMsgMap.containsKey(\"path\")) { checkBillTaskDto.setBillPath(downMsgMap.get(\"path\").toString()); }else { logger.error(\"快捷支付-对账信息 path 未配置\"); } } 3，逐笔对账 cn.swiftpass.core.server.acc.account.worker.CheckBillWorker#work jdbc逐笔对账 cn.swiftpass.core.server.acc.account.job.CheckBillPayOrderJob#execute 支付订单处理 cn.swiftpass.core.server.acc.account.job.CheckBillRefundOrderJob#execute 退款订单处理 thirdMap key不是威富通订单号 thirdPayOrder = thirdMap.get(wftPayOrder.getOrderNo())需改动 checkedThirdOrderNoSet.add(wftPayOrder.getOrderNo()) 需改动 checkedThirdOrderNoSet是已对的第三方账单Set checkBillUpDownDtos挂销账List 销账处理，过滤thirdMap中已对账的订单，剩下之前挂账的订单 cn.swiftpass.core.server.acc.account.worker.CheckBillWorker#dealRemainingBill 根据thirdMap中订单号获取本地订单信息 thirdMap key不是威富通订单号，需改动，获取威富通订单号 cn.swiftpass.core.server.acc.account.utils.ThirdMoreOrderHandler#thirdMoreOrderHandle 4，模拟造订单数据 运行bill-generator服务 修改数据库连接信息 1，下载最新导入模板 2，select * from TRA_PAY_TYPE; --- 支付类型 获取 支付类型简称，pay_type_id，pay_center_id通道id，api_code SELECT * FROM CMS_MERCHANT; --- 商户表 获取 商户号 商户编号 3，修改excel，新增订单 5，修改订单商户手续费 支付订单 SELECT * FROM PAY_ORDER ORDER BY OUT_TRADE_NO DESC; 修改 calc_state为1（计算完成），mch_theory_procedure_fee, mch_real_procedure_fee, mch_discount_fee 为0 退款订单 SELECT * FROM pay_refund ORDER BY REFUND_NO DESC; 修改 calc_state为1（计算完成）...手续费为0 5，构造第三方订单文件 按照第三方订单格式修改数据 修改订单号或者流水号为 我们造的数据 的订单号或第三方订单号等 上传到ftp 6，页面测试 1，支付通道管理配置 2，对账任务设置--选择对账时间--1，删除第三方账单 2，重新对账 3，单任务触发对账 需要关注的点 1，对账的文件是否需要过滤非数币订单？如果过滤以什么标识过滤 无须过滤 2，交易类型需要关注那几个类型？ 3，冲正单是否需要处理？ 4，三方账单的实收金额 对应 我们订单表的支付金额 totalFee 嘛? 5，三方账单模板是否有 打包顺序 transmit -> cle-bank -> cle -> acc 然后pravite-war做一次maven refers not bean 问题 1,需要在HessianConsumerConfiguration中注入 @Bean(\"InterestsApiService\") public InterestsApiService interestsApiService(){ return interestsApiService; } @HessianClient(\"interests\") InterestsApiService interestsApiService; ---------- 2,在app-config.properties中配置 hessian.interests.server=http://127.0.0.1:8001/sppay-cms-war Transmit 接口对接 1，api.json 添加对应配置 2，添加Constant常量，对应api.json中配置路径 3，reqDto，respDto 编写 4，WlmqForwardService编写 5，行内接口测试，得到返回值 6，添加数据到mock-data.json 7，编写test案例测试 打包发布镜像时要修改 https://gitlab.swifer.co/fbu-public/service-configs/service-configs-test/-/tree/master/wlmq/sppay-transmit-service/test api.json配置 Copyright © 无人问我粥可温 all right reserved，powered by Gitbook最后更新时间： 2023-12-12 09:21:50 "},"bug/后端/Mybatisplus.html":{"url":"bug/后端/Mybatisplus.html","title":"mybatisplus","keywords":"","body":"MybatisPlus 遇到的问题 dynamic-datasource-spring-boot-starter问题 报错 Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured. SpringBoot 默认是单一数据源自动配置加载，所以禁止 SpringBoot 自动注入数据源配置即可解决 解决 @SpringBootApplication(exclude = DruidDataSourceAutoConfigure.class) Copyright © 无人问我粥可温 all right reserved，powered by Gitbook最后更新时间： 2023-12-12 09:21:50 "},"bug/后端/数据库.html":{"url":"bug/后端/数据库.html","title":"数据库","keywords":"","body":"数据库 MySQL Oracle 时间类型查询区别 对应的 mybatisPlus 直接使用 likeRight Oracle日期类型字段会无效查询 MySQL GROUP_BY问题 报错：this is incompatible with sql_mode=only_full_group_by 原因 mysql5.7以上版本会出现此问题 mysql 5.7版本以上默认的sql配置是:sql_mode=”ONLY_FULL_GROUP_BY”，这个配置严格执行了”SQL92标准” ONLY_FULL_GROUP_BY 对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中。简而言之，就是SELECT后面接的列必须被GROUP BY后面接的列所包含 select a,b from table group by a,b,c; (正确) select a,b,c from table group by a,b; (错误) 查看 sql_mode select @@GLOBAL.sql_mode; 临时解决 重启mysql数据库服务之后，ONLY_FULL_GROUP_BY还会出现 set @@GLOBAL.sql_mode=\"\" set@@GLOBAL.sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 永久解决 sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 重启 service mysqld stop service mysqld start 查看状态 service mysqld status Copyright © 无人问我粥可温 all right reserved，powered by Gitbook最后更新时间： 2023-12-12 09:21:50 "},"bug/不明所以/1.html":{"url":"bug/不明所以/1.html","title":"这到底是什么问题","keywords":"","body":"不明所以的问题啊 数据渲染问题 数据更新 dom未更新 解决 dom元素加if判断 Git 403 Failed to connect to github.com port 443 : Timed out 解决 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890 Failed to connect to github.com port 443 after 21085 ms: Timed out git config --global --unset http.proxy git config --global --unset https.proxy 环境变量修改问题 修改jdk版本 如何立即生效 修改jdk版本后，直接打开cmd查看不生效， 使用win+R 打开cmd 输入 java -version 则生效 Copyright © 无人问我粥可温 all right reserved，powered by Gitbook最后更新时间： 2023-12-12 09:21:50 "}}